= Quadrature signal counter with SPI interface implemented on ATTiny25

== Features

 * Guaranteed sampling frequency of Quadrature signal even while communicating through SPI.
 * Maximum speed guaranteed to work correctly is 1 signal change in every 12 CPU clock cycles. (750 ns in case of 16MHz internal oscillator+PLL clock. 1.33MHz signal rate.)
 * Uses SPI master mode triggered by a communication enable signal: can be used on an SPI bus.
 * Detects signal overflow and sends error flag to host. This happens when two signal changes arrive in less than 12 CPU cycles.
 * Easy to use with Arduino UNO or other Arduino.
 * No support circuit is necessary more than a minimum viable uC setup:
 ** 5V TTL Quadrature AB signal directly to pins.
 ** Power capacitor
 ** Communication with host chip
 *** Chip enable
 *** SPI CK and DATA
 * Code is tested in simulator:
 ** full coverage of ASM commands.
 ** All input signal patterns are tested.
 ** Communication is tested - also in case when counting is executing during communication.
 ** It is checked that in each execution paths there is a pattern sampled in each 12 CPU cycles

== Implementation tricks

 * Interrupt-less implementation. Interrupt overhead is spared. The two tasks - communication and signal counting - are interleaved with each other manually.
 * All variables are statically allocated to registers. SRAM is not used.
 * Use a jump table (ijmp command) to decode the pattern of AB signals sampled.
 * Do not use rcall/ret but jump directly to target. It is possible because subroutines are used at on place always.
 * Use a jump table to decode current state of the communication subsystem.
 * Use jump tables with absolute addresses so additional arithmetics is not necessary to use ijmp.
 * Use PB0 and PB3 non adjacent input pins so two commands are enough to combine two samples into a single value: lsl, or. Also use swap to count the high 4 bits of the sample.
 * Decode 4 samples - 3 possible state changes at once - with one ijmp. The 256 choices are generated by a program because it is too much to manage by hand.
 * All execution path use the same amount of cycles. Time between taking two samples is always 12 CPU cycles. The program works very predictable.

== Possible improvements

 * CPU frequency can be incremented using the OSCCAL register. 20MHz must work according to the datasheet. 24MHz is possible according to my measurement. Calibration must be done at startup or before installation because there is no space in the code for that.
 * Using a uC with more program memory the jump table can be extended to process 4 signals instead of 3. That would cost a few extra cycles but would increase processing speed. 10 cycles per sample may be achievable.
 * Execute the increment subroutine more than once until the communication subroutine is executed. A few more cycles may be spared but would cost much program memory.
 * Use hw SPI to communicate (maybe slave mode). A few cycles may be spared. It seems that because HW SPI output uses PB2 and PB3 it is not possible to do the bit shifting tricks unless we use the nRESET pin as general input: that is possible but makes development a little more complex due to the required 12V reprogramming signal.

